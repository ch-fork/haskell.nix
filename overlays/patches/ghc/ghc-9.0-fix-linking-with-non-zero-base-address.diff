diff --git a/compiler/GHC/CmmToAsm/X86/CodeGen.hs b/compiler/GHC/CmmToAsm/X86/CodeGen.hs
index 2cce508a00..0ae19ce9fe 100644
--- a/compiler/GHC/CmmToAsm/X86/CodeGen.hs
+++ b/compiler/GHC/CmmToAsm/X86/CodeGen.hs
@@ -1,6 +1,7 @@
 {-# LANGUAGE CPP, GADTs, NondecreasingIndentation #-}
 {-# LANGUAGE TupleSections #-}
 {-# LANGUAGE BangPatterns #-}
+{-# LANGUAGE LambdaCase #-}
 
 #if __GLASGOW_HASKELL__ <= 808
 -- GHC 8.10 deprecates this flag, but GHC 8.8 needs it
@@ -1161,14 +1162,6 @@ getRegister' platform is32Bit (CmmLit lit)
         code dst = unitOL (MOV II32 (OpImm imm) (OpReg dst))
     in
         return (Any II64 code)
-  where
-   isBigLit (CmmInt i _) = i < 0 || i > 0xffffffff
-   isBigLit _ = False
-        -- note1: not the same as (not.is32BitLit), because that checks for
-        -- signed literals that fit in 32 bits, but we want unsigned
-        -- literals here.
-        -- note2: all labels are small, because we're assuming the
-        -- small memory model (see gcc docs, -mcmodel=small).
 
 getRegister' platform _ (CmmLit lit)
   = do let format = cmmTypeFormat (cmmLitType platform lit)
@@ -1181,6 +1174,24 @@ getRegister' _ _ other
     | otherwise        = pprPanic "getRegister(x86)" (ppr other)
 
 
+isBigLit :: CmmLit -> Bool
+isBigLit = \case
+  -- not the same as (not . is32BitLit), because that checks for signed literals
+  -- that fit in 32 bits, but we want unsigned literals here.
+  CmmInt i _                -> i < 0 || i > 0xffffffff
+
+  -- all labels are assumed big, because even with the small memory model, we
+  -- can't expect the base address to be 0, hence the absolute address
+  -- associated to a label may not fit in 32 bits.
+  CmmLabel {}               -> True
+  CmmLabelOff {}            -> True
+  CmmLabelDiffOff {}        -> True
+
+  CmmFloat {}               -> False
+  CmmVec {}                 -> False
+  CmmBlock {}               -> False
+  CmmHighStackMark {}       -> False
+
 intLoadCode :: (Operand -> Operand -> Instr) -> CmmExpr
    -> NatM (Reg -> InstrBlock)
 intLoadCode instr mem = do
@@ -1532,17 +1543,23 @@ getRegOrMem e = do
 
 is32BitLit :: Bool -> CmmLit -> Bool
 is32BitLit is32Bit lit
-   | not is32Bit = case lit of
+   | is32Bit   = True
+   | otherwise = case lit of
+      -- labels are in *relative* range 0-2^31-1 after being loaded (assuming
+      -- the small memory model (see gcc docs, -mcmodel=small)).
+      -- But their absolute value may not be in that range. In particular, with
+      -- Address Space Layout Randomization (ASLR), we can't expect the base
+      -- address to be 0.
+      CmmLabel {}               -> False
+      CmmLabelOff {}            -> False
+      CmmLabelDiffOff {}        -> False
+
       CmmInt i W64              -> is32BitInteger i
-      -- assume that labels are in the range 0-2^31-1: this assumes the
-      -- small memory model (see gcc docs, -mcmodel=small).
-      CmmLabel _                -> True
-      -- however we can't assume that label offsets are in this range
-      -- (see #15570)
-      CmmLabelOff _ off         -> is32BitInteger (fromIntegral off)
-      CmmLabelDiffOff _ _ off _ -> is32BitInteger (fromIntegral off)
-      _                         -> True
-is32BitLit _ _ = True
+      CmmInt {}                 -> True
+      CmmFloat {}               -> True
+      CmmVec {}                 -> True
+      CmmBlock {}               -> True
+      CmmHighStackMark {}       -> True
 
 
 
@@ -1785,16 +1802,26 @@ assignReg_FltCode _ reg src = do
 
 genJump :: CmmExpr{-the branch target-} -> [Reg] -> NatM InstrBlock
 
-genJump (CmmLoad mem _) regs = do
-  Amode target code <- getAmode mem
-  return (code `snocOL` JMP (OpAddr target) regs)
-
-genJump (CmmLit lit) regs = do
-  return (unitOL (JMP (OpImm (litToImm lit)) regs))
-
 genJump expr regs = do
-  (reg,code) <- getSomeReg expr
-  return (code `snocOL` JMP (OpReg reg) regs)
+  case expr of
+    CmmLoad mem _ -> do
+      Amode target code <- getAmode mem
+      return (code `snocOL` JMP (OpAddr target) regs)
+
+    CmmLit lit
+      -- We have to be careful when we jump to literals because labels can be
+      -- associated to 64-bit absolute addresses even with the small memory
+      -- model if the base address isn't 0 (see #16780).
+      --
+      -- However GAS generates 32-bit PC-relative jumps if "*" is not used
+      -- before the operand (i.e. "jmp xyz" instead of "jmp * xyz") as we do
+      -- when pretty-printing "JMP (OpImm ..)". As the executable code is still
+      -- supposed to be in a 32-bit range, the following code should be valid.
+      -> return (unitOL (JMP (OpImm (litToImm lit)) regs))
+
+    _ -> do
+      (reg,code) <- getSomeReg expr
+      return (code `snocOL` JMP (OpReg reg) regs)
 
 
 -- -----------------------------------------------------------------------------
@@ -3488,8 +3515,10 @@ genSwitch expr targets = do
   else do
         (reg,e_code) <- getSomeReg (cmmOffset platform expr offset)
         lbl <- getNewLabelNat
-        let op = OpAddr (AddrBaseIndex EABaseNone (EAIndex reg (platformWordSizeInBytes platform)) (ImmCLbl lbl))
-            code = e_code `appOL` toOL [
+        (reg_tbl,tbl_code) <- getSomeReg (CmmLit (CmmLabel lbl))
+        let op = OpAddr (AddrBaseIndex (EABaseReg reg_tbl) (EAIndex reg (platformWordSizeInBytes platform))
+                        (ImmInt 0))
+            code = e_code `appOL` tbl_code `appOL` toOL [
                     JMP_TBL op ids (Section ReadOnlyData lbl) lbl
                  ]
         return code
diff --git a/compiler/GHC/CmmToAsm/X86/Ppr.hs b/compiler/GHC/CmmToAsm/X86/Ppr.hs
index 49e4de8ad5..a3f507626d 100644
--- a/compiler/GHC/CmmToAsm/X86/Ppr.hs
+++ b/compiler/GHC/CmmToAsm/X86/Ppr.hs
@@ -615,6 +615,25 @@ pprInstr platform i = case i of
                 II64 -> II32          -- 32-bit version is equivalent, and smaller
                 _    -> format
 
+   MOV II64 src@(OpImm imm) dst
+     -> pprFormatOpOp mov_mnemonic II64 src dst
+      where
+        mov_mnemonic
+          | need_movabs = sLit "movabs"
+          | otherwise   = sLit "mov"
+        need_movabs = case imm of
+          -- if we don't use "movabs", GAS assumes that we intend to load a
+          -- zero-extended 32-bit absolute, which is wrong (#16780)
+          ImmCLbl {}         -> True
+          ImmIndex {}        -> True
+          ImmConstantSum {}  -> True
+          ImmConstantDiff {} -> True
+          ImmInt _           -> False
+          ImmInteger _       -> False
+          ImmLit _           -> False
+          ImmFloat _         -> False
+          ImmDouble _        -> False
+
    MOV format src dst
      -> pprFormatOpOp (sLit "mov") format src dst
 
